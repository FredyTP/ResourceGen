#pragma once

#include <string>
#include <fstream>
#include "FileItem.h"

class CodeGenerator
{
    
public:
    void setCodeFile(std::ofstream* _code)
    {
        code = _code;
    }
    /**
     * Adds boilerplate things to file's code.
     * 
     * \param code
     */
    virtual void codeFileBegin()
    {
        using std::endl;

        //Code HEADER
       this->addComment("This Code is autogenerated by Fredy Resources Code Generation");
       this->addComment("Please, do not modify by hand");
       this->addNewLine();
       this->makeComment("BEGIN OF AUTO-GENERATED CODE");

        //Add needed headers in derived classes
    }
    virtual void codeFileEnd()
    {
        using std::endl;
        //Code ending
        *code << this->makeComment("END OF AUTO-GENERATED CODE") << endl;
    }

    virtual void codeAddHeaders()=0;
    virtual void codeStructureBegin(std::string classname, std::string indent) = 0;
    virtual void codeStrucutreEnd(std::string classname, std::string indent) = 0;

    virtual void codeAddFile(std::string varname, std::string path, std::string indent)=0;
protected:
    /**
     * Converts the string to a code comment .
     * 
     * \param text
     * \return 
     */
    virtual std::string makeComment(std::string text)
    {
        return "//" + text;
    }
    /**
     * Converts the c++ string to string text that will be interpreted as string. Example String -> "Example String" in c++
     * 
     * \param str
     * \return 
     */
    virtual std::string makeCodeString(std::string str)
    {
        return "\"" + str + "\"";
    }
    /**
     * Add Commentary to the code. Auto endl
     * 
     * \param comment
     */
    void addComment(std::string comment)
    {
        *code << this->makeComment(comment) << std::endl;
    }

    /**
     * Adds empty line to the code.
     * 
     */
    void addNewLine()
    {
        *code << std::endl;
    }
    std::ofstream* code;
private:


};

class ResFileName
{
private:
    bool isAbsolute;
public:
    ResFileName(bool _absolute = false)
    {
        this->isAbsolute = _absolute;
    }
    /**
     * Folder name must start with an alphabet character to be valid.
     * 
     * \param folder
     * \return 
     */
    virtual bool checkNameVality(const FileItem* item)
    {
        std::string name = item->name();
        char first = name.at(0);
        if((first > 'a' && first < 'z') || (first > 'A' && first < 'Z'))
        {
            return true;
        }
        return false;
    }
    /**
     * Replace all "." and " " with "_".
     * 
     * \param folder
     * \return 
     */
    virtual std::string getClassNameFromFolder(const FileItem* folder)
    {
        std::string name = folder->name();
        std::replace(name.begin(), name.end(), ' ', '_');
        std::replace(name.begin(), name.end(), '.', '_');
        return name;

    };
    /**
     * Replace all "." and " " with "_".
     * 
     * \param file
     * \return 
     */
    virtual std::string getVarNameFromFile(const FileItem* file)
    {
        //Get and format file name
        std::string file_name = file->name();
        std::replace(file_name.begin(), file_name.end(), ' ', '_');
        std::replace(file_name.begin(), file_name.end(), '.', '_');

        return file_name;
    };
    virtual std::string getFilePath(const FileItem* file)
    {
        return this->isAbsolute? file->absolutePath().generic_string() :file->relativePath().generic_string();
    };

};
